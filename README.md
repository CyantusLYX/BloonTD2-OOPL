[![Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/CyantusLYX/BloonTD2-OOPL)
# 2025 OOPL Final Report

<span style="color:blue">some *blue* text</span>

## 組別資訊

### 組別：50
### 組員：
- 112590023 林宇祥 ID: CyantusLYX
- 112590028 高鉉 ID: KAZE-G
### 復刻遊戲：Bloons Tower Defense 2

## 專案簡介

### 遊戲簡介
Bloons Tower Defense 2 (BTD2) 是一款經典的塔防遊戲。玩家需要在地圖上策略性的放置各種擁有獨特攻擊方式的猴子塔，以阻止一波又一波五顏六色的氣球入侵並到達路線的終點。每次擊破氣球，玩家將獲得金錢獎勵，可以用來購買新的塔或升級現有的塔，以應對越來越強大的氣球。遊戲的挑戰在於如何有效地利用有限的資源，並根據不同種類氣球的特性來佈置防禦塔，成功守護(猴子的)家園。
   
### 組別分工
#### 112590023 林宇祥
- 塔架構與邏輯
- 購買按鈕配置系統
- 塔購買架構與邏輯
- 升級按鈕配置系統
- 升級架構與邏輯
- 氣球架構與邏輯
- 地圖架構與路徑系統
- 部份遊戲狀態
- 部份點擊邏輯
#### 112590028 高鉉
- 遊戲流程控制
- 按鈕架構和動作內容
- 主畫面選單
- OP模式
- 動畫及音效
- 碰撞系統
- 部分素材繪製
- 部份遊戲狀態
- 部份點擊邏輯
- 部分除錯及重構
## 遊戲介紹

### 遊戲規則
1.  **遊戲目標**：阻止氣球沿著預設路徑到達終點。每有一個氣球成功逃脫，玩家將損失一定的生命值。當生命值降至零時，遊戲結束。
2.  **放置防禦塔**：
    *   玩家可以使用初始資金在遊戲地圖的允許區域內放置各種猴子塔。
    *   每種塔都有其獨特的攻擊方式、攻擊範圍、傷害力和攻擊速度。
    *   塔理論上不能放置在路徑上或已被其他塔佔據的位置(但是我沒做：)。
3.  **氣球波次**：
    *   氣球會以波次的形式出現，每一波氣球的種類、數量和速度都會有所不同，通常後續波次的難度會逐漸增加。
    *   不同顏色的氣球代表不同的強度和特性（例如，紅色氣球最弱，藍色氣球需要被擊破兩次，黑色氣球免疫爆炸傷害等）。
4.  **獲得金錢**：
    *   成功擊破氣球可以獲得金錢。
5.  **升級防禦塔**：
    *   玩家可以使用金錢來升級已放置的防禦塔。
    *   升級可以提升塔的各項屬性，例如攻擊範圍、傷害、攻擊速度etc。
    *   每種塔有兩個升級路徑。
6.  **遊戲模式與難度**：
    *   遊戲提供不同的地圖和難度選擇，影響購買和升級成本、生命值。
7.  **特殊道具或技能**：
    *   例如：路釘、膠水等一次性道具

## 程式設計

### 程式架構
整體架構圍繞著物件導向程式設計 (OOP) 的原則（At least I think so.），將遊戲中的各個元素抽象化為類別，以實現模組化、可擴展且易於維護的()程式碼。

主要的程式架構可以分為以下幾個核心部分：

1.  **遊戲管理器 (Manager)**：
    *   作為遊戲的Control Unit，負責協調遊戲的整體流程，包括遊戲狀態（遊玩中、暫停、選單、結束）、波次管理、金錢與生命值管理、使用者輸入處理（點擊、拖曳）、物件的創建與銷毀等。
    *   維護遊戲中所有動態物件的集合，例如氣球、防禦塔、投射物等。
    *   處理物件之間的互動邏輯，例如碰撞檢測、傷害計算。

2.  **實體 (Entities)**：
    *   **防禦塔 (Tower)**：作為遊戲的核心防禦單位，`Tower` 類別 (`include/entities/tower/tower.hpp`) 是一個抽象基礎類別，定義了所有防禦塔的共通行為和屬性。它管理著塔的視覺表現、攻擊範圍、攻擊邏輯以及與遊戲系統的交互（如產生投射物）。下方有更詳細介紹。
        *   透過繼承機制，實現了多種不同類型的塔（例如：Dart Monkey, Tack Shooter, Super Monkey 等），每種塔擁有其獨特的攻擊邏輯和升級選項。
        *   搭配額外的塔的升級系統允許玩家強化塔的能力。
        *  ~~丟了一堆implement到tower.hpp,整個專案肉眼可見最黑暗的地方~~
    *   **氣球 (Bloon)**：
        *   定義了氣球的屬性，如生命值（或層數）、速度、特殊抗性（例如：免疫爆炸、免疫冰凍）等。
        *   不同顏色的氣球代表不同的強度和特性，被擊破後可能會產生下一層的氣球。
    *   **投射物 (Popper/Projectile)**：
        *   由防禦塔發射，用於攻擊氣球。例如飛鏢、釘子、炸彈等。
        *   擁有自身的移動邏輯、傷害值、穿透能力、以及可能的特殊效果（例如：爆炸、緩速）。

3.  **使用者介面 (UI)**：
    *   **按鈕 (Button)**：實現了遊戲中的各種可點擊按鈕，如開始按鈕、塔的購買按鈕、升級按鈕、販賣按鈕等。
         * 設計了一個方便配置的按鈕設定系統（用以設定圖片、價格、名稱之類的），在購買和升級按鈕使用
    *   **面板 (Panel/Container)**：用於組織和顯示相關的 UI 元素，例如塔的選擇面板、升級面板、遊戲狀態顯示（金錢、生命、波次）。
    *   **旗幟/預覽 (Flag/Preview)**：當玩家點擊一個塔時，顯示該塔的攻擊範圍以及升級/販賣(沒做;)等操作選項的介面。
    *   **狀態顯示 (Status Display)**：顯示玩家的當前金錢、生命值、目前波次等重要資訊。

4.  **核心功能 (Core)**：
    *   **路徑 (Path)**：定義氣球在地圖上移動的軌跡。
    *   **地圖 (Map)**：管理遊戲地圖的背景、路徑資訊以及可放置塔的區域。
    *   **碰撞檢測 (Collision System)**：負責檢測投射物與氣球之間、或氣球與終點之間的碰撞。
    *   **資源載入器 (Loader)**：負責從json載入遊戲所需的資源，不過只有在氣球波次設定用到...。
    *   **形狀與動畫 (Shape/ShapeAnimation)**：自(AI)製的Drawable,可以做一些基本圖形以及對應的動畫變體。

5.  **組件 (Components)**：
    *   將一些共通的功能或屬性抽象化為組件，例如 `Mortal` (可被摧毀的物件)、`CollisionComp` (碰撞組件)、`CanBuy` (可購買的物件) 等，這些組件可以被附加到不同的實體上，以增加其功能並促進程式碼複用。

6.  **介面 (Interfaces)**：
    *   定義了一系列的介面，如 `I_clickable` (可點擊的)、`I_draggable` (可拖曳的)、`I_move` (可移動的)、`I_collider` (可碰撞的)，以實現多型並解耦不同模組之間的依賴。

**幾個比較大的系統和設計介紹：**
   * **Popper(打破氣球的東東)**
        *   `popper` 類別 (`include/entities/poppers/popper.hpp`) 是所有能直接或間接對氣球造成傷害的物件的抽象基礎類別。它繼承自 `Mortal`（可以用統一的方式把它處理掉）和 `Components::CollisionComponent`（使其能夠進行碰撞檢測）。其核心設計如下：
            *   **基本屬性**：
                *   `explosive`：布林值，標記此 popper 是否具有爆炸特性。
                *   `canPopFrozen`：布林值，標記此 popper 是否能傷害冰凍狀態的氣球。
                *   `canPopBlack`：布林值，標記此 popper 是否能傷害黑色（免疫爆炸）的氣球。
                *   `life`：整數，標記此 popper 可以生效多少次（pop或減速）。
            *   **`hit` 純虛擬函式**：
                *   `virtual std::vector<bool> hit(std::vector<std::shared_ptr<Bloon>> bloons) = 0;`
                *   這是 `popper` 的核心函式，要求所有具體的 popper 子類別必須實作。
                *   它接收一個氣球列表作為參數，並返回一個布林向量，表示對應的氣球是否被此 popper 成功命中或影響。
                *   子類別在此函式中實現其獨特的效果（爆炸、集破或減速）。
            *   **子類別舉例**：
                *   **`Spike` (路釘)**：
                    *   最簡單的 popper 。當氣球接觸到它時，`hit` 函式會嘗試 `pop()`氣球。
                *   **`Dart` (飛鏢)**：
                    *   `Dart` 是一個典型直線運動的popper。繼承 `Interface::I_move` 以實現移動邏輯。
                    *   當氣球接觸到它時，`hit` 函式會嘗試 `pop()`氣球，它可能在命中一個氣球後消失（升級後有更多的life可以穿透多個氣球）。
                *   **`Boomerang` (迴旋鏢)**：
                    *   `Boomerang` 是 `I_move` 的一個更進階的應用。會按照圓形迴旋軌跡飛行。
                *   **`Bomb` (炸彈)**：
                    *   `Bomb` 的設計相對複雜。它可能是一個投射物，在命中氣球或到達特定點後觸發爆炸 (`explosive = true`)。
                    *    `hit` 函式的設計讓他有能力同時影響多顆氣球。
                    *   它需要特別處理對黑色氣球的免疫（除非 `canPopBlack` 為 `true`）。
   
* **塔（Tower）**
    *   `Tower` 類別 (`include/entities/tower/tower.hpp`) 設計核心概念：
        *   **Body 與 Range 的組合**：
            *   每個 `Tower` 物件由兩個主要的 `Util::GameObject` 組成：`m_body` 和 `m_range`。
            *   `m_body` 代表塔的視覺實體，通常顯示塔的圖片。它擁有一個 `Components::CollisionComponent`，用於判斷玩家是否點擊到塔本身（例如，用於選取塔以進行升級或販賣），同時也可以用來判定新放置的塔合不合法，但我沒做：）。
            *   `m_range` 代表塔的攻擊範圍，通常以一個半透明的圓形顯示。它也擁有一個 `Components::CollisionComponent`（圓形碰撞組件），用於檢測哪些氣球進入了塔的攻擊範圍內。當塔被選中或處於預覽模式時，這個範圍會被顯示出來。
            *   這種組合將塔的視覺表現、點擊互動區域和攻擊偵測範圍清晰地分開管理。
        *   **`handleBloonsInRange` 純虛擬函式**：
            *   這是一個純虛擬函式，要求每個具體的塔子類別（如 `DartMonkey`, `IceBall`）必須實作此函式。
            *   遊戲管理器會定期呼叫此函式，並傳入當前在該塔攻擊範圍內的所有氣球 (`bloons`) 以及它們相對於塔的距離 (`distances`)。
            *   子類別在此函式中實現其獨特的攻擊邏輯，例如選擇目標、判斷是否開火、以及如何攻擊。
            *   **舉例 - `DartMonkey`**：`DartMonkey` 在 `handleBloonsInRange` 中可能會遍歷範圍內的氣球，選擇第一個（或最接近路徑終點的）氣球作為目標，然後在其攻擊冷卻結束時，創建一個 `Dart` 投射物朝目標射擊。
            *   **舉例 - `IceBall` (冰球塔)**：`IceBall` 在 `handleBloonsInRange` 中 intervalles 等待攻擊冷卻結束，然後對範圍內所有氣球（或特定數量的氣球）產生冰凍效果，或者發射一個能造成範圍冰凍的投射物。它可能不需要特定的單一目標，而是影響一個區域。
        *   **投射物回呼函式 (`m_popperCallback`)**：
            *   `Tower` 擁有一個 `std::function<void(std::shared_ptr<popper>)> m_popperCallback` 成員。
            *   當塔創建一個投射物（`popper`）時，它會呼叫這個回呼函式，並將新創建的投射物作為參數傳遞出去。
            *   遊戲管理器會設定這個回呼函式，其目的是將新產生的投射物註冊到遊戲系統中，使其能夠被更新、渲染和進行碰撞檢測。
            *   這樣設計使得 `Tower` 本身不需要直接了解遊戲管理器的具體實現細節，只需要知道如何通知「某個東西」它產生了一個新的投射物，從而降低了耦合度。
        *   其他共通屬性與方法：包括塔的類型 (`m_type`)、狀態 (`m_state`，如 unset, ready, cooldown)、升級資訊 (`m_info`)、價格 (`m_cost`)、是否可點擊 (`IsClickable`)、預覽模式 (`m_previewMode`) 等。
* **路徑 (Path)**
    *   `Path` 類別 (`include/core/path.hpp`) 負責定義與管理氣球在遊戲地圖上的移動軌跡。其主要功能與設計如下：
        *   **路徑點集合**：`Path` 物件內部儲存了一系列的路徑點 (我們的作法是SDLPosition->PTSDPosition)，這些點依序連接起來，構成了氣球需要遵循的完整路線。
        *   **路徑生成**：路徑點被傳入後會計算總長度，透過長度可以達成位置和離路徑起點距離的互相映射。
        *   **提供氣球位置與方向**：
            *   氣球物件會向 `Path` 物件查詢其在路徑上的下一個目標位置。
            *   `Path` 提供了方法（例如 `getNextPos(currentDistance, speed)`)，讓氣球可以根據其當前已沿路徑移動的距離和速度，計算出下一個時間點應該在的位置。
            *   同時，`Path` 也能提供當前路段的方向，讓氣球可以正確地朝向移動方向。
        *   **路徑完成判斷**：`Path` 可以判斷一個氣球是否已經走完整個路徑（即到達終點）。這通常透過比較氣球已移動的距離與路徑總長度來實現。
    *   在遊戲中，每個 `Map` 物件會持有一個或多個 `Path` 物件。當氣球產生時，它會被指派到特定的路徑上，並沿著該路徑移動，直到被擊破或到達終點。路徑系統是塔防遊戲的核心機制之一，它直接影響了玩家放置防禦塔的策略。
### 程式技術
在實作過程中，除了物件導向程式設計 (OOP) 的基本原則，如封裝、繼承和多型外，還應用了一些具體的設計模式和技術來提升程式碼的彈性與可維護性。以下將介紹幾個較為核心的技術應用：

1.  **工廠模式 (Factory Pattern) - 實作於 `Manager` 類別中**：
    *   為了更有效地管理各種防禦塔 (`Tower`) 和投射物 (`Popper`) 的創建過程，我們在 `Manager` 類別中實作了工廠模式。這體現在 `Manager::initTowerFactories()` 函式以及相關的成員變數 `m_towerFactories` 和 `m_popperFactories`。
    *   **動機**：遊戲中有多種類型的塔和投射物，每種物件的初始化方式和依賴可能不同。直接在需要創建物件的地方使用 `new` 或 `std::make_shared` 會導致創建邏輯散佈在各處，增加耦合度且不易管理和擴展。
    *   **實作方式** (`src/core/tower_factory.cpp`)：
        *   `Manager` 類別擁有兩個核心的映射表 (map)：
            *   `m_towerFactories`：型別為 `std::map<Tower::TowerType, std::function<std::shared_ptr<Tower>(const Util::PTSDPosition&)>>`。它將塔的類型 (`Tower::TowerType` 枚舉) 映射到一個 Lambda 函式，該函式接收塔的放置位置作為參數，並返回一個對應塔種類的 `std::shared_ptr<Tower>`。
            *   `m_popperFactories`：類似地，這個映射表用於創建投射物 (`Popper`)，將 `Tower::TowerType` (此處可能也用作某些特殊 Popper 的標識，如 Spike 或 Glue) 映射到創建對應 `Popper` 的 Lambda 函式。
        *   在 `Manager::initTowerFactories()` 函式中，會為每種已知的塔類型（如 `DartMonkey`, `IceBall`, `TackShooter` 等）和部分投射物類型（如 `spike`, `Glue`）註冊一個創建函式到對應的映射表中。
        *   當遊戲邏輯需要創建一個新的塔或投射物時（例如，玩家點擊購買按鈕，或塔發射投射物），`Manager` 會根據所需的類型從相應的工廠映射表中查找對應的創建函式，並執行它來獲取物件實例。例如，`createTower(TowerType type, const Util::PTSDPosition& pos)` 方法會使用 `m_towerFactories[type](pos)` 來創建塔。
    *   **優點**：
        *   **集中管理創建邏輯**：所有物件的創建邏輯都集中在 `initTowerFactories` 和後續的查找調用中，使得新增或修改物件類型及其創建方式更加方便。
        *   **降低耦合**：需要創建物件的程式碼不再需要知道具體的類別名稱或其構造細節，只需要提供類型標識和必要的參數（如位置）給 `Manager` 的創建介面即可。
        *   **易於擴展**：要支援新的塔或投射物類型，只需在 `Tower::TowerType` 中添加新的枚舉值，並在 `initTowerFactories()` 中註冊對應的創建 Lambda 函式，而不需要修改大量現有程式碼。
        *   **彈性**：Lambda 函式提供了極大的彈性，可以在創建物件時執行更複雜的初始化邏輯。

2.  **回呼函式 (Callback Functions) - 以 `Tower` 的 `m_popperCallback` 為例**：
    *   在 `Tower` 類別中，我們使用了 `std::function` 來實現回呼機制，特別是 `m_popperCallback`，它允許塔在創建投射物 (`Popper`) 後，通知遊戲主循環或管理器將該投射物加入到遊戲世界中。
    *   **動機**：`Tower` 物件本身負責其攻擊邏輯並創建投射物，但它不應該直接依賴於 `Manager` 或其他高層級的遊戲迴圈類別來「註冊」這個新產生的投射物。這樣會造成 `Tower` 與 `Manager` 之間的高度耦合。
    *   **實作方式**：
        *   `Tower` 類別宣告一個 `std::function<void(std::shared_ptr<Popper>)> m_popperCallback;` 成員。
        *   在 `Manager` 創建 `Tower` 物件後，會將一個符合簽章的 Lambda 函式或成員函式指派給該 `Tower` 的 `m_popperCallback`。這個被指派的函式通常是 `Manager` 的一個方法，該方法負責將傳入的 `Popper` 加入到遊戲的活動物件列表中，以便進行後續的更新、渲染和碰撞檢測。
        *   當 `Tower`（例如在其 `handleBloonsInRange` 方法中）決定發射一個投射物時，它會創建 `Popper` 的實體，然後呼叫 `m_popperCallback(newPopper);`。
    *   **優點**：
        *   **降低耦合**：`Tower` 不需要知道 `Manager` 的具體介面或存在。它只需要知道有一個「某人」對它產生的投射物感興趣，並透過回呼函式通知即可。
        *   **提高彈性**：如果未來處理投射物的方式改變（例如，可能由不同的系統管理），只需要修改 `Manager` 中設定給 `m_popperCallback` 的函式，而 `Tower` 的程式碼不需要變動。
        *   **事件驅動**：回呼函式是實現事件驅動行為的一種有效方式。塔產生投射物可以視為一個事件，而回呼函式就是該事件的處理器。

### 遊戲流程:
1. 主畫面
   * 可選擇難度
   * 可依游標位置切換背景地圖
   * 通關會顯示相對應關卡的獎牌
   * 左上角喇叭圖樣按鈕可切換是否靜音
   * 關卡內按鈕被停用
2. 關卡
   * 難度：
      1. EASY(簡單)
      2. MED(中等)
      3. HARD(困難)
   * 波數：50波每關
   * 機制：
        1. `END GAME`按鈕將 ***清除所有關卡中的物件*** 並 *返回主畫面*
        1. 所有關卡中，相同波數的氣球 **數量** 和 **顏色/屬性** 是相同的
        2. 不同難度的生命值和初始金錢會不同
        3. 若 **氣球衝出畫面外**，則依照其本身和可以生成的所有氣球數量 *扣減生命值*
           每氣球扣除一點生命值
        4. **OP模式(DEBUG模式)** 按鈕皆為 **橘黃色系**，具有三種功能：
            1. `INFINITY`：按下時在 **灰色** 及 **橘黃色** 之間切換按鈕顏色。
               * 當按鈕顏色為**橘黃色**，*免除扣減生命值* 以及 *免費放置所有類型的塔*
               * 當按鈕顏色為**灰色**，*遊戲邏輯正常運作*
            2. `CLEAR`   ：按下後 *清除場上所有氣球* 以及可能的衍生物
            3. `SKIP +10`：按下後下一波 *向前跳十波*
        5. 終局：
            * 若 **生命值小於零** 則 *遊戲結束* 並顯示 **GAME OVER** 字樣
            * 若 **波數大於五十波** 則 *遊戲結束* 並顯示 **CONGRATULATIONS** 字樣，並於按下 **END GAME** 按鈕回歸主選單後 *顯示獲得當難度的獎牌*

透過這些設計模式和技術的應用，我們期望能建構一個更穩健、更易於擴展的遊戲系統。

## 結語

### 問題與解決方法
在實作過程中，整體而言並未遭遇無法克服的重大技術難題。開發流程相對順暢，印象中也沒有大規模重構（除了一些直接被丟掉的Copilot的探索嘗試）。

然而，也確實存在一些可以改進之處：
*   **程式碼複用性**：部分共通的功能或行為模式，未能有效地抽象化並封裝到基礎類別 (Base Class) 中。這導致在不同的衍生類別或模組間出現了些許重複的程式碼片段。不過，由於專案整體的物件類別數量尚在可控範圍內，此問題的影響相對有限。
*   **版本控制**：在協同開發過程中，曾因部分 Commit 的不規範，導致在Merge 時遇到了一些困擾，增加了不必要的時間成本。

儘管如此，這些問題都得到了適當的處理，並未對專案的最終完成造成實質性的阻礙。

### 自評

| 項次 | 項目                   | 完成 |
|------|------------------------|-------|
| 2    | 完成專案權限改為 public |  V  |
| 3    | 具有 debug mode 的功能  |  V  |
| 4    | 解決專案上所有 Memory Leak 的問題  |God knows|
| 5    | 報告中沒有任何錯字，以及沒有任何一項遺漏  |I don;t think so,|
| 6    | 遊戲可玩  |  V  |
| 7    | 程式能跑  |  V  |
| 8    | 人沒跑()  |  V  |

### 心得
112590023 林宇祥

在這個專案學到了不少東西，主要是上手之後對OOP和git有更實際的理解，用過才知道為什麼他們會被這樣設計，和學到了幾種設計模式的作法和優劣(還有現代CPP的各種神奇魔法)。

~~然後繼承真的會搞砸所有東西~~



#### 112590028 高鉉

在專案中我學習到對git的操作和維護，以及對OOP架構有更完整的概念。上學期理論課時更多是憑感覺做事，而專案的合作讓我可以更有目的性的工作。另外我也學習到了一些在記憶體管理上更安全的替代方案，以及溝通、整修各式問題。

~~比起重載建構子，輸入參數的多型在這裡更好用~~

### 貢獻比例
#### 112590023 林宇祥 60%
#### 112590028 高鉉 40%

